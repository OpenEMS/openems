= Getting Started for Newbies
:imagesdir: ../assets/images
:sectnums:
:sectnumlevels: 4
:toclevels: 4
:experimental:
:keywords: AsciiDoc
:source-highlighter: highlight.js
:icons: font

This guide helps you set up your first OpenEMS test system without any programming. You'll learn how OpenEMS works by simulating a typical home energy setup with dummy data that you can manipulate to see how the system responds.

== What You'll Build

By the end of this guide, you'll have:

* A running OpenEMS Edge system (using Docker)
* A simulated home energy setup including:
** Photovoltaic (PV) system
** Battery storage system
** Grid meter
** Non-regulated consumption meter (household appliances)
** Electric vehicle charging station (Wallbox/EVCS)
** Historical data storage (RRD4j)
* OpenEMS UI to monitor everything in your browser
* The ability to experiment with simulated values to see how OpenEMS responds

NOTE: For a guide to get OpenEMS started without Docker in a more complex setup, see the script link:https://community.openems.io/u/klinki[@klinki] shared in the xref:https://community.openems.io/t/edge-ui-deployment-ein-grober-leitfaden-raspberry-pi/729/41[Forum] to install OpenEMS, InfluxDB, Java DK, Grafana, Apache2 on a Raspberry Pi: xref:deployment-raspi.sh[Raspi Deployment].

== Prerequisites

You need:

* A computer with Docker installed (Windows, macOS, or Linux)
* Basic familiarity with using a terminal/command line
* A web browser

NOTE: If you don't have Docker installed yet, follow the instructions at https://docs.docker.com/engine/install/[docs.docker.com]. For more information about deploying OpenEMS Edge with Docker, see xref:edge/deploy/docker.adoc[Edge - Deploy to Docker].

== Step 1: Start OpenEMS with Docker

=== Create the Docker Setup

Create a new directory for your OpenEMS test system:

[source,bash]
----
mkdir openems-test
cd openems-test
----

Create a file named `docker-compose.yml` with the following content:

[source,yaml]
----
services:
  openems-edge:
    image: openems/edge:latest
    container_name: openems_edge
    hostname: openems_edge
    restart: unless-stopped
    volumes:
      - openems-edge-conf:/var/opt/openems/config:rw
      - openems-edge-data:/var/opt/openems/data:rw
    ports:
      - 8080:8080 # Apache-Felix Web Console
      - 8085:8085 # UI-Websocket

  openems-ui:
    image: openems/ui-edge:latest
    container_name: openems_ui
    hostname: openems_ui
    restart: unless-stopped
    volumes:
      - openems-ui-conf:/etc/nginx:rw
      - openems-ui-log:/var/log/nginx:rw
    environment:
      - WEBSOCKET_HOST=openems_edge
      - WEBSOCKET_PORT=8085
    ports:
      - 80:80
      - 443:443

volumes:
  openems-edge-conf:
  openems-edge-data:
  openems-ui-conf:
  openems-ui-log:
----

You can find this `docker-compose.yml` file also in the xref:tools/docker/edge/docker-compose.yml[OpenEMS Tools section about Docker for Edge & UI].

=== Start the Containers

Run the following command to start OpenEMS:

[source,bash]
----
docker compose up -d
----

=== Verify Everything is Running

Check that both containers are running:

[source,bash]
----
docker ps
----

You should see both `openems_edge` and `openems_ui` in the list.

Check the logs to ensure OpenEMS Edge is running properly:

[source,bash]
----
docker logs openems_edge
----

You should see log messages and eventually a warning: *"There are no schedulers configured!"* - this is expected and we'll fix it in the next step.

== Step 2: Configure Your First Simulated System

Now we'll configure a typical home energy system using the Apache Felix Web Console. This is the "backend" configuration interface of OpenEMS Edge. 

NOTE: Don't confuse the Apache Felix Web Console as the "backend" of the OpenEMS system we set up right now, where the UI is the "frontend", with OpenEMS Backend, which is an extra service to bring several Edge installations together for a bigger overall system. We are only using OpenEMS Edge + UI here. No need for OpenEMS Backend.

=== Access the Configuration Interface

Open your web browser and go to:

http://localhost:8080/system/console/configMgr

Login with:

* Username: `admin`
* Password: `admin`

NOTE: Port 8080 is the default port for the Apache Felix Web Console, as configured in the docker-compose.yml file above.

=== Configure the Scheduler

The Scheduler controls when and how often OpenEMS runs its algorithms (see xref:edge/architecture.adoc#_scheduler[Edge Architecture - Scheduler]).

. Click on _**Scheduler All Alphabetically**_
. Keep the default settings (they're fine for testing)
. Click btn:[Save]

You've created your first OpenEMS component with ID `scheduler0`. This scheduler executes controllers in alphabetical order.

=== Configure Debug Logging

This will show you what's happening in the logs.

. Click on _**Controller Debug Log**_
. Keep the default settings
. Click btn:[Save]

=== Configure the Websocket API

This allows the UI to connect to OpenEMS Edge.

. Click on _**Controller Api Websocket**_
. Keep the default settings
. Click btn:[Save]

=== Set Up Data Sources for Simulation

Data sources provide the simulated values that make your virtual devices "come alive." For more details on simulator components, see xref:simulation/realtime.adoc[Real-Time Simulation].

==== Household Consumption Data

. Click on _**Simulator DataSource: CSV Predefined**_
. Set the following:
** Component-ID: `datasource0`
** Source: `H0_HOUSEHOLD_SUMMER_WEEKDAY_STANDARD_LOAD_PROFILE`
. Click btn:[Save]

This simulates realistic household power consumption throughout the day. The available predefined data sources are defined in `io.openems.edge.simulator/src/io/openems/edge/simulator/datasource/csv/predefined/Source.java`.

==== Solar Production Data

. Click on _**Simulator DataSource: CSV Predefined**_ again
. Set the following:
** Component-ID: `datasource1`
** Source: `H0_HOUSEHOLD_SUMMER_WEEKDAY_PV_PRODUCTION`
. Click btn:[Save]

This simulates solar panel production on a typical summer day.

==== Non-Regulated Consumption Data (Household Appliances)

. Click on _**Simulator DataSource: CSV Predefined**_ again
. Set the following:
** Component-ID: `datasource2`
** Source: `H0_HOUSEHOLD_SUMMER_WEEKDAY_NON_REGULATED_CONSUMPTION`
. Click btn:[Save]

This simulates the power consumption of household appliances that are not directly controlled by OpenEMS (like refrigerators, washing machines, lighting, etc.).

=== Configure Simulated Devices

Now let's add the virtual devices that use these data sources.

==== Grid Meter

The grid meter measures power flow to/from the electrical grid.

. Click on _**Simulator GridMeter Reacting**_
. Set the following:
** Component-ID: `meter0`
. Click btn:[Save]

NOTE: We're using a "Reacting" grid meter, which means it automatically calculates grid power based on all other components - just like in reality! The simulator takes all meters (except grid-meters) and ESS, sums up their ActivePowers, and portrays the negative result as grid power. This equals the physical reaction of the real grid (see xref:simulation/realtime.adoc#_simulator_components[Real-Time Simulation - Simulator Components]).

==== Photovoltaic System (PV)

. Click on _**Simulator ProductionMeter Acting**_
. Set the following:
** Component-ID: `pvMeter0`
** Datasource-ID: `datasource1`
. Click btn:[Save]

==== Non-Regulated Consumption Meter (Household Appliances)

This meter represents all the household devices that consume power but aren't directly managed by OpenEMS.

. Click on _**Simulator NRCMeter Acting**_
. Set the following:
** Component-ID: `nrcMeter0`
** Datasource-ID: `datasource2`
. Click btn:[Save]

NOTE: In a real installation, OpenEMS cannot directly measure all individual household appliances spread throughout the building. Instead, it calculates non-regulated consumption by measuring the grid meter and subtracting all known loads. For testing and learning purposes, having a separate simulated meter is very helpful! See xref:simulation/realtime.adoc#_possible_combinations[Real-Time Simulation - Possible Combinations] for more details on how this works in simulation vs. reality.

==== Battery Storage System

. Click on _**Simulator EssSymmetric Reacting**_
. Set the following:
** Component-ID: `ess0`
** Initial State of Charge: `50` (starts at 50% charged)
** Capacity: `10000` (10 kWh battery)
. Click btn:[Save]

==== Electric Vehicle Charging Station (Wallbox)

. Click on _**Simulator Evcs (Electric Vehicle Charging Station)**_ (if available)
. Set the following:
** Component-ID: `evcs0`
. Click btn:[Save]

NOTE: If the Simulator Evcs component is not available in your Docker image, you can skip this step. The system will work without it.

=== Configure Historical Data Storage

RRD4j stores historical data so you can see charts and trends. RRD4j is a file-based time-series database suitable for embedded systems (see xref:edge/timedata.adoc[Edge - Timedata]).

. Click on _**Timedata RRD4J**_ (or _**Timedata.Rrd4j**_)
. Set the following:
** Component-ID: `timedata0`
. Keep other default settings
. Click btn:[Save]

=== Configure a Simple Controller

Controllers are the "brain" - they make decisions about what to do with your energy. They hold the actual business logic and are executed regularly during each cycle (see xref:edge/architecture.adoc#_controller[Edge Architecture - Controller] and xref:edge/controller.adoc[Edge - Controller]).

Let's add a simple controller that tries to maximize self-consumption of solar energy.

. Click on _**Controller Ess Balancing**_
. Set the following:
** Component-ID: `ctrlBalancing0`
** Ess-ID: `ess0`
** Grid-Meter-ID: `meter0`
. Click btn:[Save]

This controller will:

* Charge the battery when there's excess solar power
* Discharge the battery when there's not enough solar power
* Try to keep grid consumption/feed-in close to 0 W

== Step 3: View Your System in the UI

Now let's see everything in action!

=== Open the OpenEMS UI

Open your web browser and go to:

http://localhost

You should see the OpenEMS UI login screen.

=== Log In

* Username: leave empty or type `guest`
* Password: leave empty or type `admin`

Click the login button.
TODO: Check

=== Explore the Energy Monitor

You should now see the **Energy Monitor** showing:

* Grid power (import/export)
* Solar production
* Battery state of charge and power (charging/discharging)
* Non-regulated consumption (household appliances)
* Total consumption

TODO: Screenshot <ScreenCapture id="openems-ui-energy-monitor" width="800" height="400"/>

Watch the values change as the simulation runs! The system updates once per second by default, as defined by the Cycle-Time setting of "1000 ms" in the _**Core Cycle (Core.Cycle)**_ component (see xref:gettingstarted.adoc[Getting Started] and xref:edge/architecture.adoc#_controller[Edge Architecture - Controller]).
TODO: Check

=== Understanding What You See

* **Negative** grid values = feeding power to the grid
* **Positive** grid values = consuming power from the grid
* The battery charges when there's excess solar
* The battery discharges when consumption exceeds production
* The controller tries to balance everything to minimize grid dependency

== Step 4: Experiment with Your System

Now comes the fun part - playing with the system to understand how it works!

=== Manually Adjust Values

You can manually manipulate values through the Apache Felix Web Console to simulate different scenarios:

==== Simulate Different Times of Day

. Go back to http://localhost:8080/system/console/configMgr
. Find your data source configurations (`datasource0`, `datasource1`, and `datasource2`)
. You can change the data sources to different scenarios (note: currently only summer weekday profiles are available in the predefined sources)

==== Change Battery Parameters

. Find the _**Simulator EssSymmetric Reacting**_ configuration
. Try changing:
** State of Charge to see how different battery levels affect the system
** Capacity to simulate larger/smaller batteries
** Max Charge/Discharge Power to see how faster/slower batteries behave
TODO: Check

==== Observe Controller Behavior

Watch in the UI how the controller responds to:

* Times with high solar production (midday)
* Times with low/no solar production (evening)
* High consumption periods
* Low consumption periods

=== View Historical Data

After the system has been running for a while:

. In the OpenEMS UI, look for a "History" or "Chart" view
TODO: Check
. You can see graphs of how values changed over time
. This is the RRD4j timedata storage in action!

== Step 5: Add Another Controller

Let's add a second controller to see how multiple algorithms work together.

=== Understanding Controller Priority

OpenEMS runs controllers in alphabetical order by default (because we configured the "Scheduler All Alphabetically"). Controllers with higher priority (earlier in the alphabet) run first. This prioritization ensures that critical controllers can set constraints before lower-priority controllers execute (see xref:edge/architecture.adoc#_scheduler[Edge Architecture - Scheduler] for detailed information about controller prioritization).

=== Add a Charge/Discharge Time Slot Controller

This controller can force charging or discharging during specific times - useful for using cheap nighttime electricity.

TODO: This time we use the UI component install & configuration if available. Redo.

. Go to http://localhost:8080/system/console/configMgr
. Click on _**Controller Ess Time-Of-Use Tariff**_ or _**Controller Ess Charging Time Slot**_ (depending on what's available)
. Configure it to charge during specific hours
. Click btn:[Save]

Watch how this controller's behavior combines with the balancing controller!

== Step 6: Explore Available Components

OpenEMS has many pre-built components for different devices and use cases.

=== View All Available Components

In the Apache Felix Web Console (http://localhost:8080/system/console/configMgr), scroll through the list. You'll see components for:

* **Meters**: Grid meters, production meters, consumption meters
* **Energy Storage Systems (ESS)**: Various battery brands and types
* **EVCS (Wallbox)**: Different electric vehicle charger brands
* **Controllers**: Various algorithms for different optimization goals
* **IO**: Modbus, REST API, etc.
* **Schedulers**: Different ways to organize when controllers run

NOTE: Alternatively you can use the UI's component installation feature, available under Settings>Component Installation. To configure components there, or delete them, go to Settings>Component Configuration, select the component, adjust the settings or delete it.
TODO: Check


=== Customize Your System

Try adding or changing components to match your desired setup:

* Want to simulate multiple batteries? Add another ESS component
* Want to test load balancing across multiple chargers? Add an EVCS cluster
* Want different consumption patterns? Change the datasource
* You have a dynamic tariff with your grid provider? Try the tariff controllers! 
* Want to make sure the car is only charged with PV or when the price for grid power is low? Or never charged by battery power, because you will need that battery power for other consumption? Configure ...
TODO: Check

NOTE: Each component needs a unique Component-ID. Use descriptive names like `ess0`, `ess1`, `meter0`, `pvMeter0`, etc.

== Step 7: Connecting Real Devices

Once you're comfortable with the simulation, you can start integrating real hardware.

=== Replace a Simulator with Real Hardware

When you have a real device, e.g. a SOCOMEC meter, that you use as grid meter, to measure the power flow to/from the grid, you can replace the corresponding simulator component "Simulator GridMeter Acting" with the real device component "SOCOMEC Meter".
In our case of the SOCOMEC meter, it uses Modbus/RTU (Modbus over serial line) as communication protocol.

NOTE: OpenEMS uses so-called Bridge components to connect to real devices. The e.g. Modbus Bridge handles the communication protocol (e.g., Modbus TCP/RTU) and translates data to/from OpenEMS channels. The device component then uses these channels to read/write data from/to the real device.

But now let's see how to replace the simulator with the real device:

. Find the right communication bridge component for your device, e.g for our SOCOMEC Meter the "Modbus Bridge" for Modbus devices
** ...   As the first Modbus Bridge installed it will get the component ID "modbus0" by default (you can change it if you want, but they need to be unique)
. Find the non-simulator component in the configuration
** Example: in our example, the "SOCOMEC Meter"
** set the `bridge.id` to the Modbus Bridge component ID (e.g., "modbus0")
** set other required configuration parameters specific to your device
. Remove or disable the corresponding simulator component
. Click btn:[Save]

TODO: Check

OpenEMS will now read real data from your device!
TODO: EXPLAIN more

=== Mixing Simulation and Reality

You don't have to replace everything at once. You can mix:

* Real battery with simulated solar and meter
* Real meter with simulated battery
* Real solar with simulated everything else

This lets you test step by step as you acquire and install devices. Obviously, you can even test the impact of potential new devices that you consider buying in your existing real setup by simulating them first, e.g. comparing the behaviour with different sizes (capacity) or max. power ratings of batteries.

=== Device Compatibility

Many devices with similar interfaces can work with the same OpenEMS component:

Check the component descriptions and try it out! The worst that can happen is it doesn't work and you try a different component.
TODO: Check

== Step 8: When Your Device Isn't Supported

If your specific hardware isn't available as a component yet, you have two options:

=== Option 1: Request Support

. Check the https://github.com/OpenEMS/openems/issues[OpenEMS GitHub Issues] to see if someone else has requested it
. If not, create a new issue describing your device and its interface
. The community might help implement it

=== Option 2: Implement It Yourself

If you're ready to start programming, you can implement your own device driver. That's the beauty of OpenEMS - it's open source and extensible by everyone that wants to contribute!

. Follow the xref:gettingstarted.adoc[Developer Getting Started Guide] to set up a development environment
. Use the tutorial at xref:edge/implement.adoc[Implementing a Device]
. Also have a look into the coding-guidelines at xref:contribute/coding-guidelines.adoc[Coding Guidelines]
. Contribute your implementation back to the project through a Pull Request to the project's link:https://github.com/OpenEMS/openems[GitHub repo]!

This is where you transition from "user" to "developer" and can really extend OpenEMS to your needs.

TODO: Check

== Advanced: Creating a Simple Test UI
TODO: Check if this makes sense like this
original idea: Rest API + simple HTML page to manipulate values

For even more hands-on experimentation, you can create a simple HTML page to manipulate values via the JSON-RPC API.

=== Understanding the JSON-RPC API

OpenEMS exposes a JSON-RPC API that allows you to:

* Read current channel values
* Update component configurations
* Send commands to controllers

See xref:component-communication/index.adoc[Component Communication] for full details on the JSON-RPC protocol used throughout OpenEMS.

=== Example: Simple Test Page

Create a file called `test-ui.html`:

[source,html]
----
<!DOCTYPE html>
<html>
<head>
    <title>OpenEMS Test Interface</title>
    <style>
        body { font-family: Arial, sans-serif; padding: 20px; }
        .control { margin: 20px 0; padding: 15px; border: 1px solid #ccc; }
        button { padding: 10px 20px; margin: 5px; }
        input { padding: 8px; margin: 5px; }
    </style>
</head>
<body>
    <h1>OpenEMS Simple Test Interface</h1>

    <div class="control">
        <h2>Solar Production Simulator</h2>
        <label>Power (W): <input type="number" id="solarPower" value="3000"></label>
        <button onclick="setSolarPower()">Update Solar Power</button>
    </div>

    <div class="control">
        <h2>Current Values</h2>
        <button onclick="getCurrentData()">Refresh Data</button>
        <pre id="currentValues">Click refresh to see current values...</pre>
    </div>

    <script>
        // Note: This is a simplified example. Real implementation would need
        // proper WebSocket connection handling and authentication

        const EDGE_HOST = 'localhost';
        const EDGE_PORT = 8085;

        function setSolarPower() {
            const power = document.getElementById('solarPower').value;
            // This would use the JSON-RPC API to update component configuration
            alert('In a full implementation, this would update the solar production to ' + power + 'W');
            console.log('Would send JSON-RPC updateComponentConfig request');
        }

        function getCurrentData() {
            // This would use the JSON-RPC API to subscribe to channels
            alert('In a full implementation, this would fetch current values via JSON-RPC');
            console.log('Would send JSON-RPC subscribeChannels request');
        }
    </script>
</body>
</html>
----

NOTE: A full implementation would require establishing a WebSocket connection, proper authentication, and correct JSON-RPC message formatting. This is just a starting point to show the concept. For production use, refer to how the OpenEMS UI implements the connection.

=== Manipulating Values via JSON-RPC

To actually manipulate simulator values, you can use the `updateComponentConfig` JSON-RPC method via a WebSocket connection or REST API wrapper. See xref:edge/configuration.adoc[Edge Configuration] for details on the JSON structure and how to manage configuration via JSON-RPC.

== Troubleshooting

=== UI Can't Connect to Edge

* Check that both Docker containers are running: `docker ps`
* Check that port 8085 is accessible: `docker logs openems_edge | grep 8085`
* Make sure you configured the _**Controller Api Websocket**_ component

TODO: Refer to xref:edge/deploy/docker.adoc[Edge - Deploy to Docker] for more troubleshooting tips.

=== No Data Showing in UI

* Verify the scheduler is configured
* Check that all component IDs match between related components
** The grid meter needs to know about the ESS
** Controllers need correct component IDs
* Check the Docker logs for errors: `docker logs openems_edge`

=== Simulation Not Running

* Make sure the data sources are properly configured
* Verify the datasource IDs match in both the datasource and device configs
* Check that the cycle is running (look for periodic log messages)

=== Configuration Changes Not Taking Effect

* Some changes require restarting the component
* Try restarting the Docker container: `docker restart openems_edge`
TODO: Check

== Next Steps

Now that you have a working test system and understand how OpenEMS works, you can:

. **Experiment More**: Try different combinations of components and controllers
. **Connect Real Hardware**: Replace simulators with your actual devices one by one
. **Learn About Scheduling**: Explore different scheduler types for more complex controller orchestration
. **Optimize Your System**: Add controllers for peak shaving, demand response, or grid services
. **Start Developing**: If your device isn't supported, follow the xref:gettingstarted.adoc[Developer Getting Started] guide

== Get Help

If you run into issues or have questions:

* Visit the https://community.openems.io/[OpenEMS Community Forum]
* Check the https://github.com/OpenEMS/openems[GitHub Repository]
* Read more detailed documentation for xref:edge/architecture.adoc[Edge Architecture] and xref:coreconcepts.adoc[Core Concepts]

Welcome to the OpenEMS community!
